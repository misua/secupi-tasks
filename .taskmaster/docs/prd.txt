# Overview
This PRD outlines the requirements for setting up Secupi Gateway on a Kubernetes cluster using the provided Helm chart. The Secupi Gateway is a protocol-aware reverse proxy that enforces data protection and monitoring policies on connections to PostgreSQL databases. It acts as a choke point to ensure all database traffic is monitored and protected.

# Core Features
1. **Kubernetes Helm Chart Deployment**
   - Deploy Secupi Gateway using Helm chart from provided URL
   - Configure gateway with specific image tag (7.0.0.59)
   - Set up proper service types for external access

2. **PostgreSQL Database Integration**
   - Configure gateway to connect to PostgreSQL database
   - Create required database schema with customers table
   - Ensure email column exists for data protection testing

3. **Docker Registry Authentication**
   - Set up Kubernetes secret for GitLab container registry access
   - Configure image pull secrets for gateway deployment

4. **SSL Certificate Configuration**
   - Implement SSL certificate on gateway container
   - Support verify-full SSL mode for secure connections
   - Allow self-signed certificates for development environments

5. **Secupi Management Server Integration**
   - Configure SECUPI_BOOT_URL for gateway initialization
   - Enable communication with Secupi Management Console

# User Experience
- System administrators deploying Secupi Gateway on K8S clusters
- Database administrators testing data protection features
- Developers verifying email masking functionality through database queries

# Technical Architecture
## System Components
- Secupi Gateway Docker image (registry.gitlab.com/secupi/secupi-gateway:7.0.0.59)
- Kubernetes cluster with Helm 3
- PostgreSQL database instance
- Secupi Management Server (external)

## Data Models
- Required table: customers
- Required column: email (for data masking verification)

## APIs and Integrations
- Secupi Boot URL: https://damkil.azure.secupi.com/api/boot/download/1e81d3dee43740fbbcbd669a2c3ca3a7/secupi-boot-ea9abf50-9ebf-4e28-9a54-f56d75dec2e5.jar
- PostgreSQL database connection endpoint

## Infrastructure Requirements
- k3d Kubernetes cluster (lightweight local K8S solution running in Docker)
- Helm 3
- PostgreSQL database instance (can be local Docker container or deployed within k3d cluster)
- Minimum 2 CPUs and 4GB RAM per gateway instance
- Network access to Secupi container registry and Management Server on port 443
- Network access to PostgreSQL server on port 5432 (may require k3d port mapping for local access)

# Development Roadmap
## MVP Requirements (Phase 1)
- Download and extract Helm chart from provided URL
- Create Kubernetes secret for Docker registry authentication
- Configure gateway with required environment variables
- Deploy gateway with proper service configuration
- Set up PostgreSQL database with customers table
- Verify basic gateway functionality

## SSL Configuration (Phase 2)
- Create Java KeyStore with SSL certificate
- Configure gateway container for SSL termination
- Enable verify-full SSL mode support
- Test SSL connectivity

## Testing and Verification (Phase 3)
- Connect database client (e.g., DBeaver) to gateway
- Execute query: SELECT * FROM customers
- Verify email masking functionality (emails should appear as xxxxxxx)
- Document deployment process and configuration

# Logical Dependency Chain
1. First - Set up Kubernetes environment and Helm
2. Second - Create Docker registry secret
3. Third - Configure and deploy Secupi Gateway
4. Fourth - Set up PostgreSQL database with required schema
5. Fifth - Configure SSL certificate on gateway container
6. Sixth - Test and verify functionality

# Risks and Mitigations
- **Technical Challenge**: Docker registry authentication may fail if credentials are incorrect
  **Mitigation**: Verify credentials with Secupi team before deployment. For k3d setups, ensure you have network connectivity from Docker containers to GitLab registry.
- **Technical Challenge**: SSL certificate configuration complexity
  **Mitigation**: Use self-signed certificates for k3d development environments. Document the process for production certificate replacement.
- **Resource Constraint**: Local hardware limitations
  **Mitigation**: Verify local machine has adequate resources (2 CPUs, 4GB RAM minimum) before k3d cluster creation. k3d is lightweight compared to full Kubernetes installations.
- **Network Configuration**: k3d port mapping and Docker network issues
  **Mitigation**: Configure proper k3d port mappings for gateway access (port 5432) and ensure Docker networking allows access from local database clients like DBeaver.

# Appendix
## Helm Chart Details
- URL: https://storage.googleapis.com/secupi-shared/secupi-gateway-postgresql-7.0.0-59.tgz
- Required image tag: 7.0.0.59
- Service type: LoadBalancer (recommended) or NodePort/ClusterIP

## Environment Variables
- SECUPI_BOOT_URL: https://damkil.azure.secupi.com/api/boot/download/1e81d3dee43740fbbcbd669a2c3ca3a7/secupi-boot-ea9abf50-9ebf-4e28-9a54-f56d75dec2e5.jar
- GATEWAY_SERVER_HOST: PostgreSQL database hostname
- GATEWAY_SSL_ENABLED: true (for SSL configuration)
- KEYSTORE_SSL_STOREPASS: password for keystore
- KEYSTORE_SSL_ALIAS: alias name inside keystore

## Database Schema
CREATE TABLE customers (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255),
    name VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
